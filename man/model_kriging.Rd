% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/model_kriging.R
\name{model_kriging}
\alias{model_kriging}
\title{Create a GLS model and directly perform kriging}
\usage{
model_kriging(data_manifold, coords, X = NULL, Sigma_data,
  metric_manifold = "Frobenius", model_ts = "Additive",
  vario_model = "Gaussian", n_h = 15, distance = "Geodist",
  max_it = 100, tolerance = 1e-06, max_sill = NULL, max_a = NULL,
  new_coords, Sigma_new, X_new = NULL, plot = TRUE,
  suppressMes = FALSE)
}
\arguments{
\item{data_manifold}{list or array [\code{p,p,N}] of \code{N} symmetric positive definite matrices of dimension \code{nxn}}

\item{coords}{\code{N*2} or \code{N*3} matrix of [lat,long], [x,y] or [x,y,z] coordinates. [lat,long] are supposed to
be provided in signed decimal degrees}

\item{X}{matrix (N rows and unrestricted number of columns) of additional covariates for the tangent space model, possibly NULL}

\item{Sigma_data}{List of \code{N} matrices of dimension \code{p*p} representing the tangent points in correspondence of the \code{coords}}

\item{metric_manifold}{metric used on the manifold. It must be chosen among "Frobenius", "LogEuclidean", "SquareRoot"}

\item{model_ts}{type of model fitted on the tangent space. It must be chosen among "Intercept", "Coord1", "Coord2", "Additive"}

\item{vario_model}{type of variogram fitted. It must be chosen among "Gaussian", "Spherical", "Exponential"}

\item{n_h}{number of bins in the emprical variogram}

\item{distance}{type of distance between coordinates. It must be either "Eucldist" or "Geodist"}

\item{max_it}{max number of iterations for the main loop}

\item{tolerance}{tolerance for the main loop}

\item{max_sill}{maximum value allowed for \code{sill} in the fitted variogram. If NULL it is defined as \code{1.15*max(emp_vario_values)}}

\item{max_a}{maximum value for \code{a} in the fitted variogram. If NULL it is defined as \code{1.15*h_max}}

\item{new_coords}{matrix of coordinates for the \code{M} new locations where to perform kriging}

\item{Sigma_new}{List of \code{M} matrices of dimension \code{p*p} representing the tangent points in correspondence of the \code{new_coords}}

\item{X_new}{matrix (with the same number of rows of \code{new_coords}) of additional covariates for the new locations, possibly NULL}

\item{plot}{boolean. If \code{TRUE} the empirical and fitted variograms are plotted}

\item{suppressMes}{boolean. If \code{TRUE} warning messagges are not printed}
}
\value{
list with the following fields:
\item{\code{beta}}{ vector of the beta matrices of the fitted model}
\item{\code{gamma_matrix}}{ \code{N*N} covariogram matrix}
\item{\code{residuals}}{ vector of the \code{N} residual matrices}
\item{\code{emp_vario_values}}{ vector of empircal variogram values in correspondence of \code{h_vec}}
\item{\code{h_vec}}{ vector of positions at which the empirical variogram is computed}
\item{\code{fitted_par_vario}}{ estimates of \emph{nugget}, \emph{sill-nugget} and \emph{practical range}}
\item{\code{iterations}}{ number of iterations of the main loop}
\item{\code{prediction}}{ vector of matrices predicted at the new locations}
}
\description{
Given the coordinates and corresponding manifold values, this function firstly creates a GLS model on the tangent space, and then
performs kriging on the new locations.
}
\details{
For all \code{i in 1:N}, \code{data_manifold[,,i]} is mapped to the space tangent in \code{Sigma_data[,,i]}. Those values are, on their turn, 
parallely transported to the common Hilbert space tangent in the identity matrix, where a GLS model is fitted to them. A first estimate of the beta coefficients
is obtained assuming spatially uncorrelated errors. Then, in the main the loop, new estimates of the beta are obtained as a result of a
weighted least square problem where the weight matrix is the inverse of \code{gamma_matrix}. The residuals \code{(residuals = data_ts - fitted)}
are updated accordingly. The parameters of the variogram fitted to the residuals (and used in the evaluation of the \code{gamma_matrix}) are
computed using Gauss-Newton with backtrack method to solve the associated non-linear least square problem.
Once the model is computed, simple kriging on the tangent space is performed in correspondence of all the new locations \code{new_coords[j,]}, with \code{j in 1:M}. 
Then each estimate is parallely transported to the space tangent in \code{Sigma_new[,,j]} and finally mapped to the manifold.
}
\examples{
data_manifold_tot <- Manifoldgstat::fieldCov
data_manifold_model <- Manifoldgstat::rCov
coords_model <- Manifoldgstat::rGrid
coords_tot <- Manifoldgstat::gridCov
Sigma <- matrix(c(2,1,1,1), 2,2)

result = model_kriging (data_manifold = data_manifold_model, coords = coords_model, Sigma = Sigma, metric_manifold = "Frobenius",
                        metric_ts = "Frobenius", model_ts = "Coord1", vario_model = "Spherical", n_h = 15, distance = "Eucldist",
                        max_it = 100, tolerance = 10e-7,new_coords = coords_model)
result_tot = model_kriging (data_manifold = data_manifold_model, coords = coords_model, Sigma = Sigma, metric_manifold = "Frobenius",
                            metric_ts = "Frobenius",, model_ts = "Coord1", vario_model = "Spherical", n_h = 15, distance = "Eucldist",
                            max_it = 100, tolerance = 10e-7, new_coords = coords_tot, plot = FALSE)

x.min=min(coords_tot[,1])
x.max=max(coords_tot[,1])
y.min=min(coords_tot[,2])
y.max=max(coords_tot[,2])
dimgrid=dim(coords_tot)[1]
radius = 0.02

par(cex=1.25)
plot(0,0, asp=1, col=fields::tim.colors(100), ylim=c(y.min,y.max), xlim=c(x.min, x.max), pch='', xlab='', ylab='', main = "Real Values")
for(i in 1:dimgrid)
{ if(i \%\% 3 == 0) { car::ellipse(c(coords_tot[i,1],coords_tot[i,2]) , data_manifold_tot[,,i],radius=radius, center.cex=.5, col='navyblue')}}
rect(x.min, y.min, x.max, y.max)

for(i in 1:250)
{ car::ellipse(c(coords_model[i,1],coords_model[i,2]) , data_manifold_model[,,i],radius=radius, center.cex=.5, col='green')}
rect(x.min, y.min, x.max, y.max)

par(cex=1.25)
plot(0,0, asp=1, col=fields::tim.colors(100), ylim=c(y.min,y.max),xlim=c(x.min, x.max), pch='', xlab='', ylab='',main = "Predicted values")
for(i in 1:dimgrid)
{ if(i \%\% 3 == 0) { car::ellipse(c(coords_tot[i,1],coords_tot[i,2]) , (result_tot$prediction[[i]]),radius=radius, center.cex=.5, col='navyblue' )}}
rect(x.min, y.min, x.max, y.max)

for(i in 1:250)
{ car::ellipse(c(rGrid[i,1],rGrid[i,2]) , (result$prediction[[i]]),radius=radius, center.cex=.5, col='red')}
rect(x.min, y.min, x.max, y.max)
}
\references{
D. Pigoli, A. Menafoglio & P. Secchi (2016):
Kriging prediction for manifold-valued random fields.
Journal of Multivariate Analysis, 145, 117-131.

O Yair, M Ben-Chen, R Talmon (2018)
Parallel transport on the cone manifold of spd matrices for domain adaptation.
ArXiv Preprint, 1807.10479
}
